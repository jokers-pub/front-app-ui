<template>
    <div
        class="@([
            'jk-alert',
            typeClass,
            'is-' + props.effect,
            props.class,
            { 'is-center': props.center },
            props.scrollable && 'is-scrollable'
        ])"
        role="alert"
        style="display: @(model.visible?'flex':'none')">
        @if(props.showIcon || props.icon) {
            <i class="@(['jk-alert-icon', iconClass, isBigIcon])"></i>
        }
        <div class="jk-alert-content" ref="contentContainer">
            <div
                class="content"
                ref="content"
                style="transition-duration:@(model.scrollableData.duration);transform: translateX(@(model.scrollableData.offset));">
                @if(props.title || $sections.title) {
                    <span class="jk-alert-title @isBoldTitle">
                        @RenderSection("title")
                        @if(!$sections.title) {
                            <span>@props.title</span>
                        }
                    </span>
                }
                @if($sections.default && !props.description) {
                    <p class="jk-alert-description">
                        @RenderSection()
                    </p>
                }
                @if(props.description && !$sections.default) {
                    <p class="jk-alert-description">
                        @props.description
                    </p>
                }
            </div>
        </div>
        @if(props.closable) {
            <i class="jk-alert-closebtn @(props.closeText?'is-customed':'jk-icon-close')" @click="close">
                @props.closeText
            </i>
        }
    </div>
</template>
<script>
import { Component } from "@joker.front/core";

const TYPE_CLASSES_MAP = {
    success: "jk-icon-success",
    warning: "jk-icon-warning",
    error: "jk-icon-circle-close"
};

export default class extends Component<{
    title: string;
    description: string;
    type: string;
    icon: string;
    closable: boolean;
    closeText: string;
    class: string;
    showIcon: boolean;
    center: boolean;
    effect: string;
    scrollable: boolean;
}> {
    propsOption = {
        type: "info",
        closable: true,
        effect: {
            default: "light",
            validator: function (value) {
                return ["light", "dark"].includes(value);
            }
        }
    };

    model = {
        visible: true,
        scrollableData: {
            duration: "0s",
            offset: "0px"
        }
    };

    mounted() {
        if (this.props.scrollable) {
            this.$watch(
                () => this.props.title,
                () => {
                    this.initScrollable();
                }
            );
            this.initScrollable();
        }
    }
    scrollTimer: any;
    initScrollable() {
        let container: HTMLElement = this.$getRef("contentContainer")?.output;
        let content: HTMLElement = this.$getRef("content")?.output;
        let containerWidth = container.offsetWidth;
        let contentWidth = content.offsetWidth;

        // 清除可能存在的旧事件监听和定时器
        if (this.scrollTimer) {
            clearTimeout(this.scrollTimer);
        }

        // 如果内容宽度小于等于容器宽度，不需要滚动
        if (contentWidth <= containerWidth) {
            this.model.scrollableData.duration = "0s";
            this.model.scrollableData.offset = "0px";
            return;
        }

        // 配置参数
        const speed = 60; // 每秒滚动像素
        // 计算总滚动距离（内容宽度 + 容器宽度，实现完整循环）
        const totalScrollDistance = contentWidth + containerWidth;
        // 计算动画总时长（秒）
        const totalDuration = totalScrollDistance / speed;
        // 转换为毫秒
        const totalDurationMs = totalDuration * 1000;

        // 定义循环函数
        const animateLoop = () => {
            // 1. 重置位置到容器右侧（准备进入）
            this.model.scrollableData.duration = "0s";
            this.model.scrollableData.offset = containerWidth + "px";

            // 2. 短暂延迟确保重置生效
            setTimeout(() => {
                // 3. 开始动画，滚动到容器左侧外面
                this.model.scrollableData.duration = `${totalDuration}s`;
                this.model.scrollableData.offset = `-${contentWidth}px`;

                // 4. 动画结束前预约下一次循环
                this.scrollTimer = setTimeout(animateLoop, totalDurationMs);
            }, 50); // 50ms延迟确保浏览器渲染重置
        };

        // 启动第一次动画
        animateLoop();
    }

    beforeDestroy() {
        if (this.scrollTimer) {
            clearInterval(this.scrollTimer);
        }
    }

    get typeClass() {
        return "jk-alert-" + this.props.type;
    }

    get iconClass() {
        return this.props.icon || TYPE_CLASSES_MAP[this.props.type] || "jk-icon-info";
    }

    get isBigIcon() {
        return this.props.description || this.$sections.default ? "is-big" : "";
    }

    get isBoldTitle() {
        return this.props.description || this.$sections.default ? "is-bold" : "";
    }

    close() {
        this.model.visible = false;
        this.$trigger("close");
    }
}
</script>

<style lang="scss" scoped>
.jk-alert {
    padding: 8px 10px 8px 16px;
    line-height: 1;
    box-sizing: border-box;
    border-radius: 4px;
    position: relative;
    background-color: var(--jk-background-color-default);
    overflow: hidden;
    opacity: 1;
    display: flex;
    align-items: center;
    transition: opacity 0.2s;

    .jk-alert-icon.is-big {
        font-size: 20px;
    }
    &.jk-alert-success {
        &.is-light {
            background-color: #f0f9eb;
            color: #67c23a;
            .jk-alert-description {
                color: #67c23a;
            }
        }
        &.is-dark {
            background-color: #67c23a;
            color: #fff;
            .jk-alert-description {
                color: #fff;
            }
        }
    }
    &.jk-alert-info {
        &.is-light {
            background-color: #f4f4f5;
            color: #909399;
            .jk-alert-description {
                color: #909399;
            }
        }
        &.is-dark {
            background-color: #909399;
            color: #fff;
            .jk-alert-description {
                color: #fff;
            }
        }
    }
    &.jk-alert-warning {
        &.is-light {
            background-color: #fdf6ec;
            color: #e6a23c;
            .jk-alert-description {
                color: #e6a23c;
            }
        }
        &.is-dark {
            background-color: #e6a23c;
            color: #fff;
            .jk-alert-description {
                color: #fff;
            }
        }
    }
    &.jk-alert-error {
        &.is-light {
            background-color: #fef0f0;
            color: #f56c6c;
            .jk-alert-description {
                color: #f56c6c;
            }
        }
        &.is-dark {
            background-color: #f56c6c;
            color: #fff;
            .jk-alert-description {
                color: #fff;
            }
        }
    }
    &.is-center {
        justify-content: center;
    }
    .jk-alert-content {
        flex: 1;
        display: flex;
        align-items: center;
        padding: 0 8px;
        .content {
            flex: 1;
            display: flex;
            flex-direction: column;
            .jk-alert-title {
                font-size: 13px;
                line-height: 18px;
                flex: 1;
                display: flex;
                align-items: center;

                &.is-bold {
                    font-weight: 700;
                }
            }

            .jk-alert-description {
                font-size: 12px;
                margin: 5px 0 0;
            }
        }
    }
    .jk-alert-closebtn {
        font-size: 12px;
        opacity: 1;
        margin-left: 10px;
        cursor: pointer;
        &.is-customed {
            font-style: normal;
            font-size: 13px;
            top: 9px;
        }
    }
    &.is-light .jk-alert-closebtn {
        color: #c0c4cc;
    }

    &.is-scrollable {
        .jk-alert-content {
            display: flex;
            flex: 1;
            height: 16px;
            align-content: center;
            overflow: hidden;
            position: relative;
            .content {
                white-space: nowrap;
                transition-timing-function: linear;
                position: absolute;
            }
        }
    }
}
</style>