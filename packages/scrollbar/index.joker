<script>
import { Component, VNode, createCodeFunction, createCommand, createElement, createText } from "@joker.front/core";
import { scrollIntoView } from "../utils/scrollbar";
import { addResizeListener, removeResizeListener } from "../utils/resize-event";
import { componentName } from "../utils";
import JokerBar from "./bar.joker";
import { TouchBase } from "../utils/touch";
import { getValueByLang } from "../utils/lang";
export default class extends TouchBase<{
    wrapClass: string;
    viewClass: string;
    class: string;
    noresize: boolean;
    tag: string;
    height: string;
    maxHeight: string;
    width: string;
    maxWidth: string;
    pulldown: {
        enable: boolean;
        class: any;
        height: number;
        text: string;
        loosingText: string;
        loadingText: string;
        load?: () => any;
    };
}> {
    name = componentName("scrollbar");

    components = {
        JokerBar
    };

    propsOption = {
        tag: "div"
    };

    model = {
        width: "0px",
        height: "0px",
        moveX: 0,
        moveY: 0,
        touchMoveing: false,
        translateY: undefined as any,
        pulldownLoading: false
    };

    template = () => {
        return [
            createElement(
                "div",
                {
                    class: "@(['jk-scrollbar', props.class])",
                    ref: "container"
                },
                [
                    createElement(
                        "div",
                        {
                            style: "@wrapStyle",
                            ref: "wrap",
                            class: "warp @(props.wrapClass||'')",
                            "@scroll": "handleScroll(true)"
                        },
                        [
                            createCommand("if", "props.pulldown?.enable", [
                                createElement(
                                    "div",
                                    {
                                        class: "@(['pulldown-container',props.pulldown.class])",
                                        ref: "pulldown",
                                        style: "@pulldownStyle"
                                    },
                                    [
                                        createCommand("if", "$sections.pulldown", [
                                            createCommand(
                                                "RenderSection",
                                                "'pulldown',model.translateY,model.pulldownLoading"
                                            )
                                        ]),
                                        createCommand("else", undefined, [createCodeFunction("pulldownText")])
                                    ]
                                )
                            ]),
                            createElement(
                                this.props.tag!,
                                {
                                    class: "view @(props.viewClass||'')",
                                    ref: "view"
                                },
                                [createCommand("RenderSection")]
                            )
                        ]
                    ),
                    createElement("JokerBar", {
                        move: "@model.moveX",
                        size: "@model.width"
                    }),
                    createElement("JokerBar", {
                        vertical: "@true",
                        move: "@model.moveY",
                        size: "@model.height"
                    })
                ]
            )
        ];
    };

    mounted() {
        this.update();

        if (this.wrapEl && !this.props.noresize) {
            //@ts-ignore
            addResizeListener(this.viewEl, this.update);
            addResizeListener(this.wrapEl, this.update);
        }

        this.$watch(
            () => [this.props.height, this.props.maxHeight, this.props.width, this.props.maxWidth],
            () => {
                this.update();
                this.handleScroll();
            }
        );

        this.bindTouchEvent(this.wrapEl);
    }

    get wrapEl(): HTMLElement | undefined {
        return this.$getRef("wrap")?.output;
    }

    get viewEl(): HTMLElement | undefined {
        return this.$getRef("view")?.output;
    }
    get pulldownEl() {
        return this.$getRef("pulldown")?.output;
    }

    get wrapStyle() {
        return {
            height: this.props.height,
            maxHeight: this.props.maxHeight,
            width: this.props.width,
            maxWidth: this.props.maxWidth
        };
    }

    get scrollTop() {
        return this.wrapEl!.scrollTop;
    }
    get pulldownStyle() {
        return {
            height: (this.props.pulldown?.height || 40) + "px",
            marginTop:
                this.model.translateY !== undefined
                    ? `-${(this.props.pulldown.height || 40) - this.model.translateY}px`
                    : `-${this.props.pulldown?.height || 40}px`
        };
    }
    get scrollLeft() {
        return this.wrapEl!.scrollLeft;
    }

    get scrollHeight(): number {
        return this.wrapEl!.scrollHeight;
    }

    get scrollWidth(): number {
        return this.wrapEl!.scrollWidth;
    }

    get pulldownText() {
        if (this.model.pulldownLoading) {
            return this.props.pulldown?.loadingText || getValueByLang("pulldownLoading");
        } else if (this.model.translateY < (this.props.pulldown?.height || 40)) {
            return this.props.pulldown?.text || getValueByLang("pulldown");
        } else {
            return this.props.pulldown?.loosingText || getValueByLang("pulldownLoosing");
        }
    }
    update(callBack?: Function) {
        requestAnimationFrame(() => {
            let wrap = this.wrapEl;
            if (wrap) {
                let heightPercentage = (wrap.clientHeight * 100) / wrap.scrollHeight;
                let widthPercentage = (wrap.clientWidth * 100) / wrap.scrollWidth;

                this.model.height = heightPercentage < 100 ? heightPercentage + "%" : "";
                this.model.width = widthPercentage < 100 ? widthPercentage + "%" : "";
                this.$nextUpdatedRender(() => {
                    callBack?.();
                    this.$trigger("resize");
                });
            }
        });
    }

    beforeDestroy() {
        if (!this.props.noresize) {
            removeResizeListener(this.wrapEl.firstChild as HTMLElement, this.update);
            removeResizeListener(this.wrapEl, this.update);
        }
    }

    handleScroll(e?: VNode.Event, isUserScroll?: boolean) {
        let wrap = this.wrapEl;

        if (wrap) {
            this.model.moveY = (wrap.scrollTop * 100) / wrap.clientHeight;
            this.model.moveX = (wrap.scrollLeft * 100) / wrap.clientWidth;

            this.$trigger("scroll", {
                top: wrap.scrollTop,
                left: wrap.scrollLeft,
                y: wrap.scrollTop / (wrap.scrollHeight - wrap.clientHeight),
                x: wrap.scrollLeft / (wrap.scrollWidth - wrap.clientWidth),
                isUserScroll,
                isTouchMove: this.model.touchMoveing
            });
        }
    }
    getElementTranslateY(element) {
        const style = window.getComputedStyle(element);
        const transform = style.transform || style.webkitTransform;
        const translateY = transform.slice(7, transform.length - 1).split(", ")[5];

        return Number(translateY);
    }
    touchStartValue = 0;
    onTouchStart() {
        this.touchStartValue = this.scrollTop;

        this.model.touchMoveing = true;
    }
    onTouchMove(e: Event) {
        if (this.props.pulldown?.enable && this.touchStartValue === 0) {
            if (this.touchData.deltaY >= 0) {
                e.preventDefault();
                if (this.touchData.deltaY > (this.props.pulldown?.height || 40)) {
                    this.model.translateY = this.props.pulldown?.height || 40;
                } else {
                    this.model.translateY = this.touchData.deltaY;
                }
            } else {
                this.model.translateY = undefined;
            }
        }
    }
    async onTouchEnd() {
        this.model.touchMoveing = false;

        if (
            this.props.pulldown?.enable &&
            this.touchStartValue === 0 &&
            this.model.translateY >= (this.props.pulldown?.height || 40)
        ) {
            this.touchStartValue = 0;
            this.model.pulldownLoading = true;

            await this.props.pulldown.load?.();

            this.model.pulldownLoading = false;

            this.model.translateY = undefined;
            return;
        }
        this.handleScroll();
        this.touchStartValue = 0;
    }

    scrollToEl(el: HTMLElement) {
        let wrapEl = this.wrapEl;
        if (wrapEl) {
            scrollIntoView(wrapEl, el);
            this.handleScroll();
        }
    }

    scrollTo(option?: ScrollToOptions) {
        let wrapEl: HTMLElement | undefined = this.wrapEl;
        if (wrapEl) {
            wrapEl.scrollTo(option);
        }
    }
}
</script>

<style lang="scss" scoped>
.jk-scrollbar {
    overflow: hidden;
    position: relative;
    height: 100%;

    .warp {
        overflow: scroll;
        height: 100%;
        scrollbar-width: none;

        .pulldown-container {
            padding: 10px 0px;
            text-align: center;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            flex-direction: column;
            transition: 0.1s ease;
            color: var(--jk-color-text-secondary);
            font-size: 12px;
        }

        &::-webkit-scrollbar {
            width: 0;
            height: 0;
        }

        .view {
            min-height: 100%;
        }
    }

    @media (hover: hover) and (pointer: fine) {
        &:hover {
            :deep(> .jk-scrollbar-bar) {
                opacity: 1;
            }
        }
    }

    &.is-scrolling {
        :deep(.jk-scrollbar-bar) {
            display: block !important; /* 完全隐藏 */
        }
    }
}
</style>